#===============================================================================
#
# Device Config Builders
#
# GENERAL DESCRIPTION
#    Contains builder(s) definitions
#
# Copyright (c) 2011,2012, 2014 Qualcomm Technologies, Inc.
# All Rights Reserved.
# Qualcomm Confidential and Proprietary
#
#-------------------------------------------------------------------------------
#
#  $Header: //components/rel/apps.tz/1.0.7.1/bsp/build/scripts/devcfg_builder.py#1 $
#  $DateTime: 2020/01/14 12:33:12 $
#  $Author: pwbldsvc $
#  $Change: 22186812 $
#                      EDIT HISTORY FOR FILE
#                      
#  This section contains comments describing changes made to the module.
#  Notice that changes are listed in reverse chronological order.
#  
# when       who     what, where, why
# --------   ---     ---------------------------------------------------------
# 10/35/14   aa      Added Feature for collecting XML for OEM and QC separately
# 09/25/12   aa      Added Support to parse structure template expressed in xml files
# 11/14/11   jay     Device Configuration builder implementation
#===============================================================================

import os
import subprocess
import string
import re
import xml.dom.minidom
from SCons.Script import *

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------
DEVCFG_ENV_DESCRIPTOR = 'DEVCFG_INFO_COLLECTOR'
DEVCFG_XML = 'devcfg_xml'
DALCFG_DEV_ID = 'dalcfg_id'
PP_XML = 'pp_xml'
H_FILE = 'h_file'

#------------------------------------------------------------------------------
# Hooks for Scons
#------------------------------------------------------------------------------
def exists(env):
    return True

def generate(env):

    rootenv = env.get('IMAGE_ENV')
    rootenv[DEVCFG_ENV_DESCRIPTOR] = []
    
    #Add Builder to generate master xml in env
    devcfg_master_xml_generate(env)
    
    return
    
#===============================================================================
# DEVCFG Master XML build rules
#===============================================================================
def devcfg_master_xml_generate(env):
    
    """
    Generate function for devcfg builder. 
    Sets up the action, scanner and builder function to be called by clients to
    pass xml, devId details to the builder.
    """
    rootenv = env.get('IMAGE_ENV')
    
    # load builder into environment
    # Add method to environment. 
    # AddDevCfgInfo is the function that needs to be called by the clients to pass
    # dev cfg xml file name with location, devID is needed to be added, APIs needed
    # to compile any .h files included in the xml file.
    rootenv.AddMethod(add_devcfg_info, "AddDevCfgInfo")
    # load builder into environment
    # Set action_source to None as there are no sources passed into the action function. 
    # If this isn't set explicitly, then build command with verbose=2 fails.
    devcfg_act = env.GetBuilderAction(devcfg_xml_builder, action_source=None)
    devcfg_target_scan = env.Scanner(devcfg_target_scan_func, name='DevCfgTargetScanner')
    devcfg_bld = env.Builder(action = devcfg_act,
                             target_scanner = devcfg_target_scan,
                             suffix = '.xml')
    rootenv.Append(BUILDERS = {'DevcfgBuilder' : devcfg_bld})
    return

#===============================================================================
# Scanner for DEVCFG Master XML builder
#===============================================================================    
def devcfg_target_scan_func(node, env, path):
    """
    Scanner adds the include paths to dal config environment which will 
    be used to compile autogenerated c files while rebuilding. This gets
    called from the dal config scons environment.
    """
    rootenv = env.get('IMAGE_ENV')
    #Instead of returning any nodes just add the PP XMLs and H_FILE as deps
    #Before building master xml, define rules to build preprocess and structure header
    for build_tag in rootenv.get('BUILD_TAGS') :
      [env.Depends(node, sub_dict.get(build_tag, [])) for sub_dict in  rootenv.get('DEVCFG_INFO_COLLECTOR', [])]
      [env.Depends(node, sub_dict.get(build_tag+'_C', [])) for sub_dict in  rootenv.get('DEVCFG_INFO_COLLECTOR', [])]
    
    return []
    
def devcfg_find_xml_file(env, config_list):
    xml_config_list = []
    for file in config_list :
       file_path = env.RealPath(file)
       if(str(file_path).lower().endswith('.xml')):
          xml_config_list.append(file)
    
    #remove all xml files
    for file in xml_config_list :
      config_list.remove(file) 
    return config_list, xml_config_list
    
def devcfg_find_c_file(env, config_list):
    c_config_list = []
    for file in config_list :
       file_path = env.RealPath(file)
       if(str(file_path).lower().endswith('.c')):
          c_config_list.append(file)
    
    #remove all xml files
    for file in c_config_list :
      config_list.remove(file) 
    return config_list, c_config_list

#===============================================================================
# Method exposed by DEV Config Master XML Builder for scanning xml files
#===============================================================================    
def add_devcfg_info(env, targets, thread_input_dict):
    """
    When AddDevCfgInfo is called by the client, this add_devcfg_xml gets invoked in the
    devcfg builder env & the details passed by the clients are stored in a dictionary here.
    """
    #import pdb;pdb.set_trace()
    rootenv = env.get('IMAGE_ENV')
    if rootenv.GetUsesFlag('USES_DEVCFG') is False:
        return
    
    # if not list, create list     
    if type(targets) is not list:
       targets = [targets]
       
    # if its not DEV_CFG image and if its not audio, sensor or q6_sw based on ASSO_FLAG then return
    relvance = False
    for build_tag in targets :
      if build_tag in env.get('BUILD_TAGS') :
         relvance = True
         break
    
    if relvance is False:
      return
    
    #import pdb;pdb.set_trace()
    # Dictionary to hold dal device id and device config xml locations
    newDict = {}

    # DEVCFG_XML needs to be passed whenever AddDevCfgInfo is called from the client scons file.
    if DEVCFG_XML not in thread_input_dict:
        devcfg_error(env, DEVCFG_XML + 'required')
   
    # if not list, create list
    if type(thread_input_dict[DEVCFG_XML]) is not list:
       thread_input_dict[DEVCFG_XML] = [thread_input_dict[DEVCFG_XML]]
      
    # create list for c and xml files
    config_list = thread_input_dict[DEVCFG_XML]
    config_list, xml_config_list = devcfg_find_xml_file(env, config_list)
    config_list, c_config_list = devcfg_find_c_file(env, config_list)
    if(len(config_list)!=0):
       devcfg_error(env, str(config_list) + "file of unsupported type")

    # Devcfg xml file name along with the path is stored in the dictionary
    newDict[DEVCFG_XML] = xml_config_list
    
    # Check to see if the xml file passed through scons exists
    for file in xml_config_list :
       if env.PathExists(file) is False:
           errStr = 'File not found: ' + str(file)
           devcfg_error(env, errStr)
    
    # Check for duplicates in the xml files passed in
    for grpList in rootenv[DEVCFG_ENV_DESCRIPTOR]:
        if newDict[DEVCFG_XML] == grpList.get(DEVCFG_XML, "BADXMLFILE"):
           # If its a duplicate, do not process
           env.PrintWarning("Duplicate Device Configuration Input File Specified " + str(newDict[DEVCFG_XML]))
           return

    # Add xml files in Global List
    for xml_file in xml_config_list :       
       #Full path to the XML file
       xml_fullpath = env.RealPath(xml_file)
             
       #Obtain just the file name + ext
       xml_fname = os.path.basename(xml_fullpath)
                
       #Preprocess the XML
       pp_xml = env.PreProcess('${BUILDPATH}/' + xml_fname + '.pp', xml_file)
       
       #Cleanup the Preprocessed XML
       pp_xml_cl = env.PreProcessClean('${BUILDPATH}/' + xml_fname + '.i', pp_xml)
          
       for build_tag in targets :
         if build_tag in env.get('BUILD_TAGS') :
            #newDict[build_tag] = pp_xml_cl
            newDict.setdefault(build_tag, [  ]).append(pp_xml_cl[0])

    for c_file in c_config_list :
      output_obj_cnode = env.AddObject(targets , c_file)
      for build_tag in targets :
         newDict.setdefault(build_tag+'_C', [  ]).append(output_obj_cnode[0])
       
    # Add the user supplied info to the rootenv dictionary
    rootenv[DEVCFG_ENV_DESCRIPTOR].append(newDict)
      
    #print 'rootenv[DEVCFG_ENV_DESCRIPTOR]: ', rootenv[DEVCFG_ENV_DESCRIPTOR]
        
    return
 
   
#===============================================================================
# Builder def to generate a Master XML file
#===============================================================================  
def devcfg_xml_builder(target, source, env):
    """
    devcfg_xml_builder gets invoked as its a rule in dal\config\SConscript to create the master xml file
    and DALDeviceId_autogen.h.
    The master xml file will be the #includes of all the xml files passed by the clients.
    DALDeviceId_autogen.h will have #define for all the dal device ids passed thro' the drivers' scons file.
    target[0] will have the master xml location & name.
    target[1] will have the location & name for DALDeviceId_autogen.h.
    """
    rootenv = env.get('IMAGE_ENV')
      
    if rootenv.GetUsesFlag('USES_DEVCFG') is False:
        return None
    
    # Find out list of files that need to be processed.
    try:
        data_keys = env['DATA_COLLECT']
    except :
        data_keys = []
        
    # Creation of master dal xml file
    target_full = env.RealPath(str(target[0]))
    target_env_full = env.RealPath(str(target[1]))
    master_xml = devcfg_create_master_xml_file(rootenv, target_full, target_env_full, data_keys, env)
    
    return

#===============================================================================
# Internal Module to create master dal xml that include all xml files passed 
# in by various scons files. Invoked from Master XML builder.
#===============================================================================     
def devcfg_create_master_xml_file(env, filepathname, env_filepathname, data_keys, dalenv):
    """
    devcfg_create_master_xml_file creates the master dal xml file that includes all the 
    xml files passed in by various scons files
    """
    # Determine the module name that needs to be added to the module tag in the xml file
    moduleName = ''
    proc_name = env.get('PROC_CONFIG')
    
    if proc_name == 'wcn':
        moduleName = 'wcn'
    elif proc_name == 'modem':
        moduleName = 'modem'
    elif env.has_key('CORE_SPS'):
        moduleName = 'dsps'
    elif env.has_key('CORE_RPM') or env.has_key('RPM_IMAGE'):
        moduleName = 'rpm'
    elif env.has_key('TZOS_IMAGE'):
        moduleName = 'tz'
    elif env.has_key('HYPERVISOR_IMAGE'):
        moduleName = 'hyp' 
    elif env.has_key('DAL_DEVCFG_OEM_IMG'): 
	     moduleName = 'oem'
    elif env.has_key('BUILD_BOOT_CHAIN') or env.has_key('BUILD_TOOL_CHAIN'):
        moduleName = 'boot'
    elif env.has_key('APPS_PROC'):
        moduleName = 'apps'
    else:
        # If none of the above are applicable, then throw an error to indicate 
        # that a proper build env needs to be present for module name
        devcfg_error(env, 'Need image definition for determining module name for dal master cfg file')
    moduleNameStr = '<module name="' + moduleName + '">\n'
    
    # Create the master xml file and open for writing
    try:
        devcfg_xml_file = open(filepathname, 'w')
        devcfg_env_file = open(env_filepathname, 'w')
    except IOError:
        errStr = 'Could not create dal master XML file' + filepathname
        devcfg_error(env, errStr)
    
    
    HeaderList = []
    HeaderPath = []

    # Add the include files and the xml header tags
    devcfg_xml_file.write('#include "DALPropDef.h"\n')
    devcfg_xml_file.write('#include "DALDeviceId.h"\n')
    devcfg_xml_file.write('#include "dalconfig.h"\n\n')
    devcfg_xml_file.write('<?xml version="1.0"?>\n')
    devcfg_xml_file.write('<dal>\n')
    devcfg_xml_file.write(moduleNameStr)
       
    # Write all the xml files as #includes in the xml file
    #import pdb; pdb.set_trace()
    for xml_loc in env[DEVCFG_ENV_DESCRIPTOR]:
        for key in data_keys :
           if(xml_loc.has_key(key)): # found a match with key and build tag
               for xml_node in xml_loc[key]: # go over all xml files with associated key
                  pp_cl_file_node = xml_node
                  path_pp_cl_file = xml_node.path
                  path_pp_file = re.sub(r'\.i$','.pp',path_pp_cl_file)
                  #get Header information (Header files and their Paths) from the corresponding .pp files
                  pp_xml_file_fp = open(str(path_pp_file),"r")
                  hdr_path_line = ""
                  for line in pp_xml_file_fp:
                      if line.startswith('#'):
                          hdr_path_line = line.split('"')[1]
                          build_root = str(env.get('BUILD_ROOT')).replace('\\', '/')
                          hdr_path_line_new = re.sub('\\\\+','/',hdr_path_line)
                          hdr_path, hdr_file = os.path.split(hdr_path_line_new)
                          if '.h' in hdr_file.lower() and build_root.lower() in hdr_path_line_new.lower() :
                              hdr_file = 'enum_header_path "' + hdr_file + '"\n'
                              if hdr_file not in HeaderList:
                                  HeaderList.append(hdr_file)
                                  devcfg_xml_file.write(hdr_file)
                              if hdr_path not in HeaderPath:
                                  HeaderPath.append(hdr_path)
                                  devcfg_env_file.write(hdr_path + "\n")
                               
                  pp_xml_file_fp.close()
                  devcfg_xml_file.write(pp_cl_file_node.get_contents())
                  devcfg_xml_file.write('\n')
            
    # Write the closing tags
    devcfg_xml_file.write('</module>' + '\n')
    devcfg_xml_file.write('</dal>\n')        
        
    # Close the Master XML file
    devcfg_xml_file.close()
    devcfg_env_file.close()

    #Store Header Paths extracted to environment
    dalenv.get('CPPPATH').extend(HeaderPath)
    return
    
#===============================================================================
# Dev Config Error Handler
#=============================================================================== 

def devcfg_error(env, Info, Info1=None):
    """
    Error handler for devcfg framework. Info can be a string that describes the error and
    Info1 can be any data that needs to be printed along with the error message.
    """
    env.PrintError("DevCfg error found: " + Info)
    env.PrintError(Info1)
    raise Exception(Info)
